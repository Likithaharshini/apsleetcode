LeetCode 977 – Squares of a Sorted Array


Problem Statement:-

Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

Program :-
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        int l = 0, r = n - 1, k = n - 1;

        while (l <= r) {
            if (nums[l] * nums[l] > nums[r] * nums[r]) {
                res[k--] = nums[l] * nums[l];
                l++;
            } else {
                res[k--] = nums[r] * nums[r];
                r--;
            }
        }
        return res;
    }
}

Output:-
Input:  [-4,-1,0,3,10]
Output: [0,1,9,16,100]

LeetCode 219 – Contains Duplicate II


Problem Statement:-

Given an integer array nums and an integer k, return true if there are two distinct indices i and j such that nums[i] == nums[j] and |i - j| <= k.

Program :-
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashSet<Integer> set = new HashSet<>();

        for (int i = 0; i < nums.length; i++) {
            if (set.contains(nums[i])) return true;
            set.add(nums[i]);
            if (set.size() > k) set.remove(nums[i - k]);
        }
        return false;
    }
}

Output
Input: nums = [1,2,3,1], k = 3
Output: true

LeetCode 1480 – Running Sum of 1D Array


Problem Statement:-

Given an array nums, return the running sum where runningSum[i] = sum(nums[0]…nums[i]).

Program (Java)
class Solution {
    public int[] runningSum(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            nums[i] += nums[i - 1];
        }
        return nums;
    }
}

Output
Input:  [1,2,3,4]
Output: [1,3,6,10]

LeetCode 704 – Binary Search


Problem Statement:-

Given a sorted array and a target value, return the index if found, else return -1.

Program (Java)
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) l = mid + 1;
            else r = mid - 1;
        }
        return -1;
    }
}

Output
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4

LeetCode 75 – Sort Colors:-

Problem Statement

Sort an array containing 0, 1, and 2 without using a sorting algorithm.

Program (Java)
class Solution {
    public void sortColors(int[] nums) {
        int low = 0, mid = 0, high = nums.length - 1;

        while (mid <= high) {
            if (nums[mid] == 0) {
                int t = nums[low];
                nums[low++] = nums[mid];
                nums[mid++] = t;
            } else if (nums[mid] == 1) {
                mid++;
            } else {
                int t = nums[mid];
                nums[mid] = nums[high];
                nums[high--] = t;
            }
        }
    }
}

Output
Input:  [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

LeetCode 121 – Best Time to Buy and Sell Stock:-

Problem Statement:-

Find the maximum profit by buying and selling one stock.

Program (Java)
class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE, profit = 0;
        for (int p : prices) {
            if (p < min) min = p;
            else profit = Math.max(profit, p - min);
        }
        return profit;
    }
}

Output
Input:  [7,1,5,3,6,4]
Output: 5

LeetCode 283 – Move Zeroes:-

Problem Statement:-

Move all zeroes to the end while maintaining the relative order of non-zero elements.

Program (Java)
class Solution {
    public void moveZeroes(int[] nums) {
        int idx = 0;
        for (int n : nums) if (n != 0) nums[idx++] = n;
        while (idx < nums.length) nums[idx++] = 0;
    }
}

Output
Input:  [0,1,0,3,12]
Output: [1,3,12,0,0]

LeetCode 344 – Reverse String:-

Problem Statement:-

Reverse the given character array in-place.

Program (Java)
class Solution {
    public void reverseString(char[] s) {
        int l = 0, r = s.length - 1;
        while (l < r) {
            char t = s[l];
            s[l++] = s[r];
            s[r--] = t;
        }
    }
}

Output
Input:  ['h','e','l','l','o']
Output: ['o','l','l','e','h']

LeetCode 933 – Number of Recent Calls:-


Problem Statement:-

Count requests within the last 3000 milliseconds.

Program :-
class RecentCounter {
    Queue<Integer> q = new LinkedList<>();

    public int ping(int t) {
        q.offer(t);
        while (q.peek() < t - 3000) q.poll();
        return q.size();
    }
}

Output
Input: ping(1), ping(100), ping(3001), ping(3002)
Output: 3

LeetCode 102 – Binary Tree Level Order Traversal:-

Problem Statement:-

Return level order traversal of a binary tree.

Program (Java)
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) return res;

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while (!q.isEmpty()) {
            int size = q.size();
            List<Integer> level = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode n = q.poll();
                level.add(n.val);
                if (n.left != null) q.offer(n.left);
                if (n.right != null) q.offer(n.right);
            }
            res.add(level);
        }
        return res;
    }
}

Output
Input:  [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
eetCode 199 – Binary Tree Right Side View
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) return res;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode n = q.poll();
                if (i == size - 1) res.add(n.val);
                if (n.left != null) q.add(n.left);
                if (n.right != null) q.add(n.right);
            }
        }
        return res;
    }
}

LeetCode 622 – Design Circular Queue:-

class MyCircularQueue {
    int[] q; int front = 0, rear = -1, size = 0;
    public MyCircularQueue(int k) { q = new int[k]; }
    public boolean enQueue(int v) {
        if (isFull()) return false;
        rear = (rear + 1) % q.length;
        q[rear] = v; size++; return true;
    }
    public boolean deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % q.length;
        size--; return true;
    }
    public int Front() { return isEmpty() ? -1 : q[front]; }
    public int Rear() { return isEmpty() ? -1 : q[rear]; }
    public boolean isEmpty() { return size == 0; }
    public boolean isFull() { return size == q.length; }
}




LeetCode 641 – Design Circular Deque:-
class MyCircularDeque {
    int[] dq; int front = 0, rear = -1, size = 0;
    public MyCircularDeque(int k) { dq = new int[k]; }

    public boolean insertFront(int v) {
        if (isFull()) return false;
        front = (front - 1 + dq.length) % dq.length;
        dq[front] = v; size++; return true;
    }
    public boolean insertLast(int v) {
        if (isFull()) return false;
        rear = (rear + 1) % dq.length;
        dq[rear] = v; size++; return true;
    }
    public boolean deleteFront() { if (isEmpty()) return false; front = (front + 1) % dq.length; size--; return true; }
    public boolean deleteLast() { if (isEmpty()) return false; rear = (rear - 1 + dq.length) % dq.length; size--; return true; }
    public int getFront() { return isEmpty() ? -1 : dq[front]; }
    public int getRear() { return isEmpty() ? -1 : dq[rear]; }
    public boolean isEmpty() { return size == 0; }
    public boolean isFull() { return size == dq.length; }
}




LeetCode 621 – Task Scheduler:-
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] f = new int[26];
        for (char c : tasks) f[c - 'A']++;
        Arrays.sort(f);

        int idle = (f[25] - 1) * n;
        for (int i = 24; i >= 0 && f[i] > 0; i--)
            idle -= Math.min(f[i], f[25] - 1);

        return idle > 0 ? idle + tasks.length : tasks.length;
    }
}




LeetCode 933 – Number of Recent Calls:-
class RecentCounter {
    Queue<Integer> q = new LinkedList<>();
    public int ping(int t) {
        q.add(t);
        while (q.peek() < t - 3000) q.poll();
        return q.size();
    }
}
